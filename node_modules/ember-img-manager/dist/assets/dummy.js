define('dummy/app', ['exports', 'ember', 'ember/resolver', 'ember/load-initializers', './config/environment'], function (exports, Ember, Resolver, loadInitializers, config) {

  'use strict';

  Ember['default'].MODEL_FACTORY_INJECTIONS = true;

  var App = Ember['default'].Application.extend({
    modulePrefix: config['default'].modulePrefix,
    podModulePrefix: config['default'].podModulePrefix,
    Resolver: Resolver['default']
  });

  loadInitializers['default'](App, config['default'].modulePrefix);

  exports['default'] = App;

});
define('dummy/components/img-wrap', ['exports', 'ember', '../mixins/img-manager/in-viewport'], function (exports, Ember, ImgManagerInViewportMixin) {

  'use strict';

  var IMG_ATTRIBUTES = ["id", "title", "align", "alt", "border", "height", "hspace", "ismap", "longdesc", "name", "width", "usemap", "vspace"];

  var computed = Ember['default'].computed;
  var readOnly = computed.readOnly;
  var oneWay = computed.oneWay;
  var run = Ember['default'].run;
  var bind = run.bind;
  var once = run.once;
  var on = Ember['default'].on;


  /**
   * @module img-manager/img-source
   * @class Current
   * @property {ImgSource} source
   * @property {ImgCloneHolder} cloneHolder
   */

  /**
   * @class ImgWrapComponent
   * @extends Ember.Component
   *
   * @property {ImgManagerService} manager
   */
  var ImgWrapComponent;
  ImgWrapComponent = Ember['default'].Component.extend(ImgManagerInViewportMixin['default'], {
    /**
     * @inheritDoc
     */
    attributeBindings: ["style"],

    /**
     * @inheritDoc
     */
    tagName: "span",

    /**
     * @inheritDoc
     */
    classNames: ["img-wrap"],

    /**
     * @inheritDoc
     */
    classNameBindings: ["statusClass"],

    /**
     * The css styles of our span
     * @property style
     * @type {string}
     */
    style: "display: inline-block;",


    /**
     * The src attribute of the image
     * @property src
     * @type {string}
     */
    src: computed(function (key, value, oldValue) {
      if (arguments.length > 1 && value !== oldValue) {
        once(this, "_updateSrc", value);
      }
      return value;
    }),

    /**
     * Update the src property and its dependencies
     *
     * @method _updateSrc
     * @param {string} src
     * @private
     */
    _updateSrc: function (src) {
      var imgSource, cloneHolder;
      this.releaseCloneHolder();
      if (src) {
        imgSource = this.manager.imgSourceForSrc(src);
        cloneHolder = imgSource.createClone(this.getProperties(IMG_ATTRIBUTES), this.get("_cloneHolderActionHandler"));
        this.setProperties({
          imgSource: imgSource,
          cloneHolder: cloneHolder
        });
        this._insertImgNode();
      }
    },


    /**
     * Releases the clone holder
     *
     * @method releaseCloneHolder
     */
    releaseCloneHolder: on("destroy", function () {
      var cloneHolder = this.get("cloneHolder");
      if (cloneHolder) {
        this.get("imgSource").releaseClone(cloneHolder);
      }
      this.setProperties({
        cloneHolder: null,
        imgSource: null
      });
    }),

    /**
     * Our image source
     * @property imgSource
     * @type {ImgSource}
     */
    imgSource: null,

    /**
     * Our clone holder
     * @property cloneHolder
     * @type {ImgCloneHolder}
     */
    cloneHolder: null,

    /**
     * Is it loading the source image?
     * @property isLoading
     * @type {boolean}
     */
    isLoading: readOnly("imgSource.isLoading"),

    /**
     * Did the source image fail to load?
     * @property isError
     * @type {boolean}
     */
    isError: readOnly("imgSource.isError"),

    /**
     * Did the source image succeed to load?
     * @property isSuccess
     * @type {boolean}
     */
    isSuccess: readOnly("imgSource.isSuccess"),

    /**
     * How many percent have been loaded so far?
     * @property progress
     * @type {number}
     */
    progress: readOnly("imgSource.progress"),

    /**
     * Lazy load
     * @property lazyLoad
     * @type {boolean}
     */
    lazyLoad: oneWay("imgSource.lazyLoad"),

    /**
     * Loading class
     * @property loadingClass
     * @type {string}
     */
    loadingClass: oneWay("manager.defaultLoadingClass"),

    /**
     * Error class
     * @property errorClass
     * @type {string}
     */
    errorClass: oneWay("manager.defaultErrorClass"),

    /**
     * Success class
     * @property successClass
     * @type {string}
     */
    successClass: oneWay("manager.defaultSuccessClass"),

    /**
     * The css class related to the current status
     * @property statusClass
     * @type {string}
     */
    statusClass: computed("imgSource.isLoading", "imgSource.isError", "imgSource.isSuccess", "loadingClass", "errorClass", "successClass", function () {
      var imgSource, opt;
      imgSource = this.get("imgSource");
      if (!imgSource) {
        return this.get("loadingClass");
      }
      opt = imgSource.getProperties("isLoading", "isError", "isSuccess");
      if (opt.isLoading) {
        return this.get("loadingClass");
      } else if (opt.isError) {
        return this.get("errorClass");
      } else if (opt.isSuccess) {
        return this.get("successClass");
      }
    }).readOnly(),

    /**
     * Inserts the clone in the element if this one is in the DOM
     *
     * @method _insertImgNode
     */
    _insertImgNode: on("didInsertElement", function () {
      var cloneHolder;
      if (this._state === "inDOM" && (cloneHolder = this.get("cloneHolder"))) {
        this.get("element").appendChild(cloneHolder.node);
        this._scheduleSourceLoad();
      }
    }),

    /**
     * Initialize our component
     *
     * @method _setupImgWrap
     * @private
     */
    _setupImgWrap: on("init", function () {
      if (!this.get("lazyLoad")) {
        this.set("enteredViewport", true);
      }
    }),

    /**
     * Starts loading the source when the element enter the viewport
     *
     * @method _scheduleSourceLoad
     */
    _scheduleSourceLoad: on("didEnterViewport", function () {
      var imgSource = this.get("imgSource");
      if (imgSource && this._state === "inDOM" && this.get("enteredViewport")) {
        //Ember.debug('[img-manager] Scheduling load for `' + imgSource.get('src') + '`.');
        imgSource.scheduleLoad();
      }
    }),

    /**
     * The handler called when the source is changed
     * @property _cloneHolderActionHandler
     * @type {Function}
     */
    _cloneHolderActionHandler: computed(function () {
      return bind(this, function (action, imgNode) {
        var imgSource, event;
        if (action === "change") {
          imgSource = this.get("imgSource");
          if (imgSource) {
            this._insertImgNode();
            if (imgSource.get("isSuccess")) {
              event = "load-success";
            } else if (imgSource.get("isError")) {
              event = "load-error";
            }
            if (event) {
              this.sendAction(event, imgNode);
            }
          }
        }
      });
    })
  });

  // now create the setters for each image attribute so that we can update them on each clone
  var extra = {};
  Ember['default'].EnumerableUtils.forEach(IMG_ATTRIBUTES, function (name) {
    extra[name] = computed(function (key, value) {
      var current;
      if (arguments.length > 1 && !this.isDestroying && !this.isDestroyed && this._state === "inDOM") {
        current = this.get("cloneHolder");
        if (current && current.cloneHolder.clone) {
          current.cloneHolder.setAttribute(name, value);
        }
      }
      return value;
    });
  });
  ImgWrapComponent.reopen(extra);

  exports['default'] = ImgWrapComponent;

});
define('dummy/controllers/img-wrap/hooks', ['exports', 'ember'], function (exports, Ember) {

  'use strict';

  function hookHandler(type, id) {
    return function (img) {
      // using unshift so that the `hooked` returns the last one registered
      this.get("hooks").unshift({ type: type, id: id, img: img });
    };
  }

  exports['default'] = Ember['default'].Controller.extend({
    imgSrc1: null,
    imgSrc2: null,
    imgSrc3: null,

    hooks: Ember['default'].computed(function () {
      return [];
    }),

    hooked: function (type, id) {
      return this.get("hooks").find(function (hooked) {
        return (!type || hooked.type === type) && (!id || hooked.id === id);
      });
    },

    hookeds: function (type, id) {
      return this.get("hooks").filter(function (hooked) {
        return (!type || hooked.type === type) && (!id || hooked.id === id);
      });
    },

    resetHooks: function () {
      this.notifyPropertyChange("hooks");
    },

    actions: {
      didSuccess1: hookHandler("success", 1),
      didSuccess2: hookHandler("success", 2),
      didSuccess3: hookHandler("success", 3),
      didError1: hookHandler("error", 1),
      didError2: hookHandler("error", 2),
      didError3: hookHandler("error", 3)
    }
  });

});
define('dummy/initializers/export-application-global', ['exports', 'ember', '../config/environment'], function (exports, Ember, config) {

  'use strict';

  exports.initialize = initialize;

  function initialize(container, application) {
    var classifiedName = Ember['default'].String.classify(config['default'].modulePrefix);

    if (config['default'].exportApplicationGlobal) {
      window[classifiedName] = application;
    }
  };

  exports['default'] = {
    name: "export-application-global",

    initialize: initialize
  };

});
define('dummy/initializers/img-manager-service', ['exports'], function (exports) {

  'use strict';

  exports.initialize = initialize;

  function initialize(container, application) {
    application.inject("component:img-wrap", "manager", "service:img-manager");
    application.inject("view", "imgManagerService", "service:img-manager");
  }

  exports['default'] = {
    name: "img-manager-service",
    initialize: initialize
  };

});
define('dummy/mixins/img-manager/in-viewport', ['exports', 'ember'], function (exports, Ember) {

  'use strict';

  // Inspired from:
  // https://github.com/twokul/ember-lazy-image
  // https://medium.com/delightful-ui-for-ember-apps/ember-js-detecting-if-a-dom-element-is-in-the-viewport-eafcc77a6f86

  var on = Ember['default'].on;
  var get = Ember['default'].get;
  var debounce = Ember['default'].run.debounce;
  var scheduleOnce = Ember['default'].run.scheduleOnce;
  var computed = Ember['default'].computed;
  var bind = Ember['default'].run.bind;
  var next = Ember['default'].run.next;

  /**
   * @mixin ImgManagerInViewportMixin
   * @extension ImgManagerInViewportMixin
   * @uses Ember.Evented
   */
  exports['default'] = Ember['default'].Mixin.create(Ember['default'].Evented, {
    /**
     * The timeout to observe scrolling
     * @property scrollTimeout
     * @type {number}
     */
    scrollTimeout: 100,

    /**
     * Set to true when it entered viewport
     * @property enteredViewport
     * @type {boolean}
     */
    enteredViewport: computed(function (key, value, oldValue) {
      if (arguments.length > 1) {
        if (value) {
          this._unbindScroll();
          if (!oldValue) {
            //Ember.debug('[img-manager] Element entered viewport: ' + this + '.');
            next(this, "trigger", "didEnterViewport");
          }
        }
      } else {
        value = false;
      }
      return value;
    }),

    /**
     * Updates the `enteredViewport` property
     *
     * @method _setViewport
     * @private
     */
    _setViewport: function () {
      var rect;
      if (this.isDestroying || this.isDestroyed || this._state !== "inDOM" || this.get("enteredViewport")) {
        return;
      }
      rect = this.$()[0].getBoundingClientRect();
      this.set("enteredViewport", rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth));
    },

    /**
     * Set the initial value of `enteredViewport`
     *
     * @method _setInitialViewport
     * @private
     */
    _setInitialViewport: on("didInsertElement", function () {
      scheduleOnce("afterRender", this, "_setViewport");
    }),

    /**
     * Handles the scroll event
     *
     * @method _scrollHandler
     * @private
     */
    _scrollHandler: function () {
      debounce(this, "_setViewport", get(this, "scrollTimeout"));
    },

    /**
     * Starts listening for the scroll event
     *
     * @method _bindScroll
     * @private
     */
    _bindScroll: on("didInsertElement", function () {
      this._unbindScroll();
      if (!this.get("enteredViewport")) {
        this._boundScrollHandler = bind(this, "_scrollHandler");
        Ember['default'].$(document).on("touchmove", this._boundScrollHandler);
        Ember['default'].$(window).on("scroll", this._boundScrollHandler);
      }
    }),

    /**
     * Stops listening for the scroll event
     *
     * @method _bindScroll
     * @private
     */
    _unbindScroll: on("willDestroyElement", function () {
      if (this._boundScrollHandler) {
        Ember['default'].$(window).off("scroll", this._boundScrollHandler);
        Ember['default'].$(document).off("touchmove", this._boundScrollHandler);
        this._boundScrollHandler = null;
      }
    })
  });

});
define('dummy/router', ['exports', 'ember', './config/environment'], function (exports, Ember, config) {

  'use strict';

  var Router = Ember['default'].Router.extend({
    location: config['default'].locationType
  });

  Router.map(function () {
    this.route("img-wrap", function () {
      this.route("simple");
      this.route("delayed-src");
      this.route("switch-src");
      this.route("hooks");
    });
  });

  exports['default'] = Router;

});
define('dummy/services/img-manager', ['exports', 'ember', '../utils/img-manager/img-rule', '../utils/img-manager/img-source', '../config/environment', '../utils/img-manager/simple-map'], function (exports, Ember, ImgRule, ImgSource, ENV, SimpleMap) {

  'use strict';

  var map = Ember['default'].EnumerableUtils.map;
  var computed = Ember['default'].computed;
  var readOnly = computed.readOnly;
  var bind = Ember['default'].run.bind;

  /**
   * @module img-manager
   * @class ImgManagerService
   * @extends Ember.Object
   */
  exports['default'] = Ember['default'].Object.extend({
    /**
     * Our configuration
     * @property config
     * @type {Object}
     */
    config: computed(function () {
      return Ember['default'].merge({
        maxTries: 1,
        loadingClass: "loading",
        errorClass: "error",
        successClass: "success",
        lazyLoad: true
      }, Ember['default'].get(ENV['default'], "imgManager"));
    }).readOnly(),

    /**
     * The default delay
     * @property defaultDelay
     * @type {number}
     */
    defaultDelay: readOnly("config.delay"),

    /**
     * The default lazyLoad
     * @property defaultLazyLoad
     * @type {boolean}
     */
    defaultLazyLoad: readOnly("config.lazyLoad"),

    /**
     * The default batch size
     * @property defaultBatchSize
     * @type {number}
     */
    defaultBatchSize: readOnly("config.batchSize"),

    /**
     * The default max tries
     * @property defaultMaxTries
     * @type {number}
     */
    defaultMaxTries: readOnly("config.maxTries", 1),

    /**
     * The default loading src
     * @property defaultLoadingSrc
     * @type {number}
     */
    defaultLoadingSrc: readOnly("config.loadingSrc"),

    /**
     * The default error src
     * @property defaultErrorSrc
     * @type {number}
     */
    defaultErrorSrc: readOnly("config.errorSrc"),

    /**
     * Default css class for the wrapper of a loading image
     * @property defaultLoadingClass
     * @type {string}
     */
    defaultLoadingClass: readOnly("config.loadingClass"),

    /**
     * Default css class for the wrapper of an image which failed to load
     * @property defaultErrorClass
     * @type {string}
     */
    defaultErrorClass: readOnly("config.errorClass"),

    /**
     * Default css class for the wrapper of an image which loaded successfully
     * @property defaultSuccessClass
     * @type {string}
     */
    defaultSuccessClass: readOnly("config.successClass"),


    /**
     * Get the img source object for the given src
     *
     * @method imgSourceForSrc
     * @param {string} src
     * @return {ImgSource}
     */
    imgSourceForSrc: function (src) {
      var dict = this.get("_imgSources"),
          imgSource = dict.get(src);
      if (!imgSource) {
        dict.set(src, imgSource = src ? ImgSource['default'].create({
          src: src,
          manager: this
        }) : null);
        if (imgSource) {
          this.incrementProperty("totalSources");
          imgSource.one("didError", bind(this, "incrementProperty", "totalErrors", 1));
        }
      }
      return imgSource;
    },

    /**
     * Contains all the rules
     * @property rules
     * @type {Ember.Array.<ImgRule>}
     */
    rules: computed(function () {
      var _this = this;
      var rules = Ember['default'].A(map(this.get("config.rules") || [], function (ruleConfig) {
        return ImgRule['default'].create({
          manager: _this,
          config: ruleConfig
        });
      }));
      // add a default rule matching everything
      rules.pushObject(ImgRule['default'].create({
        manager: this,
        config: { match: "*" }
      }));
      return rules;
    }).readOnly(),


    /**
     * Get the first rule matching the given src
     *
     * @method ruleForSrc
     * @param {string} src
     * @return {ImgRule}
     */
    ruleForSrc: function (src) {
      return this.get("rules").find(function (rule) {
        return rule.test(src);
      });
    },

    /**
     * Total number of hits
     * @property totalHits
     * @type {number}
     */
    totalHits: 0,

    /**
     * Total number of errors
     * @property totalErrors
     * @type {number}
     */
    totalErrors: 0,

    /**
     * Total number of used clones
     * @property totalUsedClones
     * @type {number}
     */
    totalUsedClones: 0,

    /**
     * Total number of free clones
     * @property totalFreeClones
     * @type {number}
     */
    totalFreeClones: 0,

    /**
     * Total number of sources
     * @property totalSources
     * @type {number}
     */
    totalSources: 0,

    /**
     * All img source objects indexed by src
     * @property _imgSources
     * @type {Object}
     */
    _imgSources: computed(function () {
      return new SimpleMap['default']();
    }).readOnly()
  });

});
define('dummy/templates/application', ['exports', 'ember'], function (exports, Ember) {

  'use strict';

  exports['default'] = Ember['default'].Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
  helpers = this.merge(helpers, Ember['default'].Handlebars.helpers); data = data || {};
    var buffer = '', stack1;


    data.buffer.push("<h2 id=\"title\">Welcome to Ember.js</h2>\n\n");
    stack1 = helpers._triageMustache.call(depth0, "outlet", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    return buffer;
    
  });

});
define('dummy/templates/components/img-wrap', ['exports', 'ember'], function (exports, Ember) {

  'use strict';

  exports['default'] = Ember['default'].Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
  helpers = this.merge(helpers, Ember['default'].Handlebars.helpers); data = data || {};
    var buffer = '';


    return buffer;
    
  });

});
define('dummy/templates/img-wrap/delayed-src', ['exports', 'ember'], function (exports, Ember) {

  'use strict';

  exports['default'] = Ember['default'].Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
  helpers = this.merge(helpers, Ember['default'].Handlebars.helpers); data = data || {};
    var buffer = '', helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


    data.buffer.push("<div class=\"img-container\">\n  ");
    data.buffer.push(escapeExpression((helper = helpers['img-wrap'] || (depth0 && depth0['img-wrap']),options={hash:{
      'src': ("imgSrc"),
      'alt': ("Cartoon 1")
    },hashTypes:{'src': "ID",'alt': "STRING"},hashContexts:{'src': depth0,'alt': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "img-wrap", options))));
    data.buffer.push("\n</div>\n");
    data.buffer.push(escapeExpression((helper = helpers.input || (depth0 && depth0.input),options={hash:{
      'id': ("img-src"),
      'value': ("imgSrc")
    },hashTypes:{'id': "STRING",'value': "ID"},hashContexts:{'id': depth0,'value': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "input", options))));
    data.buffer.push("\n");
    return buffer;
    
  });

});
define('dummy/templates/img-wrap/hooks', ['exports', 'ember'], function (exports, Ember) {

  'use strict';

  exports['default'] = Ember['default'].Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
  helpers = this.merge(helpers, Ember['default'].Handlebars.helpers); data = data || {};
    var buffer = '', helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


    data.buffer.push("<div class=\"img-1\">\n  ");
    data.buffer.push(escapeExpression((helper = helpers['img-wrap'] || (depth0 && depth0['img-wrap']),options={hash:{
      'src': ("imgSrc1"),
      'load-success': ("didSuccess1"),
      'load-error': ("didError1")
    },hashTypes:{'src': "ID",'load-success': "STRING",'load-error': "STRING"},hashContexts:{'src': depth0,'load-success': depth0,'load-error': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "img-wrap", options))));
    data.buffer.push("\n</div>\n<div class=\"img-2\">\n  ");
    data.buffer.push(escapeExpression((helper = helpers['img-wrap'] || (depth0 && depth0['img-wrap']),options={hash:{
      'src': ("imgSrc2"),
      'load-success': ("didSuccess2"),
      'load-error': ("didError2")
    },hashTypes:{'src': "ID",'load-success': "STRING",'load-error': "STRING"},hashContexts:{'src': depth0,'load-success': depth0,'load-error': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "img-wrap", options))));
    data.buffer.push("\n</div>\n<div class=\"img-3\">\n  ");
    data.buffer.push(escapeExpression((helper = helpers['img-wrap'] || (depth0 && depth0['img-wrap']),options={hash:{
      'src': ("imgSrc3"),
      'load-success': ("didSuccess3"),
      'load-error': ("didError3")
    },hashTypes:{'src': "ID",'load-success': "STRING",'load-error': "STRING"},hashContexts:{'src': depth0,'load-success': depth0,'load-error': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "img-wrap", options))));
    data.buffer.push("\n</div>\n");
    return buffer;
    
  });

});
define('dummy/templates/img-wrap/simple', ['exports', 'ember'], function (exports, Ember) {

  'use strict';

  exports['default'] = Ember['default'].Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
  helpers = this.merge(helpers, Ember['default'].Handlebars.helpers); data = data || {};
    var buffer = '', helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


    data.buffer.push("<div class=\"img-container\">\n  ");
    data.buffer.push(escapeExpression((helper = helpers['img-wrap'] || (depth0 && depth0['img-wrap']),options={hash:{
      'src': ("assets/images/cartoon-1.jpg"),
      'alt': ("Cartoon 1")
    },hashTypes:{'src': "STRING",'alt': "STRING"},hashContexts:{'src': depth0,'alt': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "img-wrap", options))));
    data.buffer.push("\n</div>\n");
    return buffer;
    
  });

});
define('dummy/templates/img-wrap/switch-src', ['exports', 'ember'], function (exports, Ember) {

  'use strict';

  exports['default'] = Ember['default'].Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
  helpers = this.merge(helpers, Ember['default'].Handlebars.helpers); data = data || {};
    var buffer = '', helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


    data.buffer.push("<div class=\"img-container\">\n  ");
    data.buffer.push(escapeExpression((helper = helpers['img-wrap'] || (depth0 && depth0['img-wrap']),options={hash:{
      'src': ("imgSrc"),
      'alt': ("Cartoon 1")
    },hashTypes:{'src': "ID",'alt': "STRING"},hashContexts:{'src': depth0,'alt': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "img-wrap", options))));
    data.buffer.push("\n</div>\n");
    data.buffer.push(escapeExpression((helper = helpers.input || (depth0 && depth0.input),options={hash:{
      'id': ("img-src"),
      'value': ("imgSrc")
    },hashTypes:{'id': "STRING",'value': "ID"},hashContexts:{'id': depth0,'value': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "input", options))));
    data.buffer.push("\n");
    return buffer;
    
  });

});
define('dummy/tests/acceptance/img-wrap/delayed-src-test', ['ember', '../../helpers/start-app', 'dummy/utils/img-manager/img-clone-holder', '../../helpers/later'], function (Ember, startApp, img_clone_holder) {

  'use strict';

  var application;

  module("Acceptance: should update the image after the src changed", {
    setup: function () {
      application = startApp['default']();
    },
    teardown: function () {
      Ember['default'].run(application, "destroy");
    }
  });

  test("visiting /img-wrap/delayed-src", function () {
    var $imgContainer;
    visit("/img-wrap/delayed-src");
    andThen(function () {
      fillIn("#img-src", "assets/images/cartoon-1.jpg");
      later(10);
    });
    andThen(function () {
      equal(currentPath(), "img-wrap.delayed-src");
      $imgContainer = find(".img-container");
      equal($imgContainer.find("img").attr("src"), "assets/images/cartoon-1.jpg");
      equal($imgContainer.find("img").attr("alt"), "Cartoon 1");
    });
  });

});
define('dummy/tests/acceptance/img-wrap/hooks-test', ['ember', '../../helpers/start-app', 'dummy/utils/img-manager/img-clone-holder', '../../helpers/controller-for', '../../helpers/later'], function (Ember, startApp, img_clone_holder) {

  'use strict';

  var VALID_SRC = "assets/images/cartoon-1.jpg";
  var INVALID_SRC = "__dummy_not_exists__.jpg";

  var application;

  module("Acceptance: should trigger the `load-success` and `load-error` hooks", {
    setup: function () {
      application = startApp['default']();
    },
    teardown: function () {
      Ember['default'].run(application, "destroy");
    }
  });

  test("visiting /img-wrap/hooks", function () {
    var $img1Container, $img2Container, $img3Container, controller;
    visit("/img-wrap/hooks");
    andThen(function () {
      controller = controllerFor("img-wrap/hooks");
      $img1Container = find(".img-1");
      $img2Container = find(".img-2");
      $img3Container = find(".img-3");
      later(50);
    });
    andThen(function () {
      ok(!controller.hooked(), "No hook should have been called yet");
      controller.setProperties({
        imgSrc1: VALID_SRC,
        imgSrc2: VALID_SRC,
        imgSrc3: VALID_SRC
      });
      later(50);
    });
    andThen(function () {
      ok(controller.hooked("success", 1), "Success should have been called for img 1");
      ok(controller.hooked("success", 2), "Success should have been called for img 2");
      ok(controller.hooked("success", 3), "Success should have been called for img 3");
      equal(controller.hookeds().length, 3, "Only 3 hooks should have been called");
      controller.resetHooks();
      controller.setProperties({
        imgSrc1: INVALID_SRC,
        imgSrc2: INVALID_SRC,
        imgSrc3: INVALID_SRC
      });
      later(50);
    });
    andThen(function () {
      ok(controller.hooked("error", 1), "Error should have been called for img 1");
      ok(controller.hooked("error", 2), "Error should have been called for img 2");
      ok(controller.hooked("error", 3), "Error should have been called for img 3");
      equal(controller.hookeds().length, 3, "Only 3 hooks should have been called");
      controller.resetHooks();
    });
  });

});
define('dummy/tests/acceptance/img-wrap/simple-test', ['ember', '../../helpers/start-app', 'dummy/utils/img-manager/img-clone-holder', '../../helpers/later'], function (Ember, startApp, img_clone_holder) {

  'use strict';

  var application;

  module("Acceptance: should render a simple image", {
    setup: function () {
      application = startApp['default']();
    },
    teardown: function () {
      Ember['default'].run(application, "destroy");
    }
  });

  test("visiting /img-wrap/simple", function () {
    var $imgContainer;
    visit("/img-wrap/simple");
    andThen(function () {
      later(10);
    });
    andThen(function () {
      equal(currentPath(), "img-wrap.simple");
      $imgContainer = find(".img-container");
      equal($imgContainer.find("img").attr("src"), "assets/images/cartoon-1.jpg");
      equal($imgContainer.find("img").attr("alt"), "Cartoon 1");
    });
  });

});
define('dummy/tests/acceptance/img-wrap/switch-src-test', ['ember', '../../helpers/start-app', 'dummy/utils/img-manager/img-clone-holder', '../../helpers/later'], function (Ember, startApp, img_clone_holder) {

  'use strict';

  var application;

  module("Acceptance: should update the image after the src changed", {
    setup: function () {
      application = startApp['default']();
    },
    teardown: function () {
      Ember['default'].run(application, "destroy");
    }
  });

  test("visiting /img-wrap/delayed-src", function () {
    var $imgContainer;
    visit("/img-wrap/delayed-src");
    andThen(function () {
      fillIn("#img-src", "assets/images/cartoon-1.jpg");
      later(10);
    });
    andThen(function () {
      equal(currentPath(), "img-wrap.delayed-src");
      $imgContainer = find(".img-container");
      equal($imgContainer.find("img").attr("src"), "assets/images/cartoon-1.jpg");
      equal($imgContainer.find("img").attr("alt"), "Cartoon 1");
    });
    andThen(function () {
      fillIn("#img-src", "assets/images/cartoon-2.jpg");
      later(10);
    });
    andThen(function () {
      equal($imgContainer.find("img").attr("src"), "assets/images/cartoon-2.jpg");
      equal($imgContainer.find("img").attr("alt"), "Cartoon 1");
    });
  });

});
define('dummy/tests/app.jshint', function () {

  'use strict';

  module('JSHint - .');
  test('app.js should pass jshint', function() { 
    ok(true, 'app.js should pass jshint.'); 
  });

});
define('dummy/tests/controllers/img-wrap/hooks.jshint', function () {

  'use strict';

  module('JSHint - controllers/img-wrap');
  test('controllers/img-wrap/hooks.js should pass jshint', function() { 
    ok(true, 'controllers/img-wrap/hooks.js should pass jshint.'); 
  });

});
define('dummy/tests/dummy/tests/acceptance/img-wrap/delayed-src-test.jshint', function () {

  'use strict';

  module('JSHint - dummy/tests/acceptance/img-wrap');
  test('dummy/tests/acceptance/img-wrap/delayed-src-test.js should pass jshint', function() { 
    ok(true, 'dummy/tests/acceptance/img-wrap/delayed-src-test.js should pass jshint.'); 
  });

});
define('dummy/tests/dummy/tests/acceptance/img-wrap/hooks-test.jshint', function () {

  'use strict';

  module('JSHint - dummy/tests/acceptance/img-wrap');
  test('dummy/tests/acceptance/img-wrap/hooks-test.js should pass jshint', function() { 
    ok(true, 'dummy/tests/acceptance/img-wrap/hooks-test.js should pass jshint.'); 
  });

});
define('dummy/tests/dummy/tests/acceptance/img-wrap/simple-test.jshint', function () {

  'use strict';

  module('JSHint - dummy/tests/acceptance/img-wrap');
  test('dummy/tests/acceptance/img-wrap/simple-test.js should pass jshint', function() { 
    ok(true, 'dummy/tests/acceptance/img-wrap/simple-test.js should pass jshint.'); 
  });

});
define('dummy/tests/dummy/tests/acceptance/img-wrap/switch-src-test.jshint', function () {

  'use strict';

  module('JSHint - dummy/tests/acceptance/img-wrap');
  test('dummy/tests/acceptance/img-wrap/switch-src-test.js should pass jshint', function() { 
    ok(true, 'dummy/tests/acceptance/img-wrap/switch-src-test.js should pass jshint.'); 
  });

});
define('dummy/tests/dummy/tests/helpers/controller-for.jshint', function () {

  'use strict';

  module('JSHint - dummy/tests/helpers');
  test('dummy/tests/helpers/controller-for.js should pass jshint', function() { 
    ok(true, 'dummy/tests/helpers/controller-for.js should pass jshint.'); 
  });

});
define('dummy/tests/dummy/tests/helpers/later.jshint', function () {

  'use strict';

  module('JSHint - dummy/tests/helpers');
  test('dummy/tests/helpers/later.js should pass jshint', function() { 
    ok(true, 'dummy/tests/helpers/later.js should pass jshint.'); 
  });

});
define('dummy/tests/dummy/tests/helpers/resolver.jshint', function () {

  'use strict';

  module('JSHint - dummy/tests/helpers');
  test('dummy/tests/helpers/resolver.js should pass jshint', function() { 
    ok(true, 'dummy/tests/helpers/resolver.js should pass jshint.'); 
  });

});
define('dummy/tests/dummy/tests/helpers/start-app.jshint', function () {

  'use strict';

  module('JSHint - dummy/tests/helpers');
  test('dummy/tests/helpers/start-app.js should pass jshint', function() { 
    ok(true, 'dummy/tests/helpers/start-app.js should pass jshint.'); 
  });

});
define('dummy/tests/dummy/tests/test-helper.jshint', function () {

  'use strict';

  module('JSHint - dummy/tests');
  test('dummy/tests/test-helper.js should pass jshint', function() { 
    ok(true, 'dummy/tests/test-helper.js should pass jshint.'); 
  });

});
define('dummy/tests/helpers/controller-for', ['ember'], function (Ember) {

  'use strict';

  Ember['default'].Test.registerHelper("controllerFor", function (app, name) {
    return app.__container__.lookup("controller:" + name);
  });

});
define('dummy/tests/helpers/later', ['ember'], function (Ember) {

  'use strict';

  Ember['default'].Test.registerAsyncHelper("later", function (app, delay) {
    Ember['default'].run.later(Ember['default'], "K", delay);
  });

});
define('dummy/tests/helpers/resolver', ['exports', 'ember/resolver', '../../config/environment'], function (exports, Resolver, config) {

  'use strict';

  var resolver = Resolver['default'].create();

  resolver.namespace = {
    modulePrefix: config['default'].modulePrefix,
    podModulePrefix: config['default'].podModulePrefix
  };

  exports['default'] = resolver;

});
define('dummy/tests/helpers/start-app', ['exports', 'ember', '../../app', '../../router', '../../config/environment'], function (exports, Ember, Application, Router, config) {

  'use strict';

  function startApp(attrs) {
    var application;

    var attributes = Ember['default'].merge({}, config['default'].APP);
    attributes = Ember['default'].merge(attributes, attrs); // use defaults, but you can override;

    Ember['default'].run(function () {
      application = Application['default'].create(attributes);
      application.setupForTesting();
      application.injectTestHelpers();
    });

    return application;
  }
  exports['default'] = startApp;

});
define('dummy/tests/router.jshint', function () {

  'use strict';

  module('JSHint - .');
  test('router.js should pass jshint', function() { 
    ok(true, 'router.js should pass jshint.'); 
  });

});
define('dummy/tests/test-helper', ['./helpers/resolver', 'ember-qunit'], function (resolver, ember_qunit) {

	'use strict';

	ember_qunit.setResolver(resolver['default']);

	document.write("<div id=\"ember-testing-container\"><div id=\"ember-testing\"></div></div>");

	QUnit.config.urlConfig.push({ id: "nocontainer", label: "Hide container" });
	var containerVisibility = QUnit.urlParams.nocontainer ? "hidden" : "visible";
	document.getElementById("ember-testing-container").style.visibility = containerVisibility;

});
define('dummy/utils/img-manager/dom-helpers', ['exports'], function (exports) {

  'use strict';

  /**
   * @module img-manager
   * @type {{attach: Function, detach: Function, attachOnce: Function}}
   */
  var helpers = {
    /**
     * Listen for an event on an HTML element
     *
     * @param {HTMLElement} node
     * @param {String} event
     * @param {Function} handler
     * @returns {Boolean}
     */
    attach: function (node, event, handler) {
      if (node.addEventListener) {
        node.addEventListener(event, handler, false);
      } else if (node.attachEvent) {
        node.attachEvent("on" + event, handler);
      } else {
        return false;
      }
      return true;
    },

    /**
     * Stop listening for an event on an HTML element
     *
     * @param {HTMLElement} node
     * @param {String} event
     * @param {Function} handler
     * @returns {Boolean}
     */
    detach: function (node, event, handler) {
      if (node.removeEventListener) {
        node.removeEventListener(event, handler, true);
      } else if (node.detachEvent) {
        node.detachEvent("on" + event, handler);
      } else {
        return false;
      }
      return true;
    },

    /**
     * Listen for an HTML event once
     *
     * @param {HTMLElement} node
     * @param {String} event
     * @param {Function} handler
     */
    attachOnce: function (node, event, handler) {
      var wrapper = function () {
        helpers.detach(node, event, wrapper);
        handler.apply(this, arguments);
      };

      return helpers.attach(node, event, wrapper);
    }
  };

  exports['default'] = helpers;

});
define('dummy/utils/img-manager/img-clone-holder', ['exports', 'ember', './img-node-factory'], function (exports, Ember, imgFactory) {

  'use strict';

  // this class is in purpose not Ember, for faster processing
  var EnumerableUtils = Ember['default'].EnumerableUtils;
  var assert = Ember['default'].assert;
  var forEach = EnumerableUtils.forEach;
  var filter = EnumerableUtils.filter;
  var hasOwn = ({}).hasOwnProperty;
  var run = Ember['default'].run;
  var next = run.next;

  var TRANSPARENT_PIXEL = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";

  /**
   * Set an attribute of a node
   *
   * @function setAttr
   * @param {HTMLElement} node
   * @param {string} name
   * @param {*} value
   */
  var setAttr = (function (hasSetAttr) {
    if (hasSetAttr) {
      return function (node, name, value) {
        node.setAttribute(name, value);
      };
    } else {
      return function (node, name, value) {
        node[name] = value;
      };
    }
  })(typeof document.createElement("img").setAttribute === "function");


  /**
   * @class ImgCloneHolder
   * @constructor
   */
  function ImgCloneHolder() {
    this.handler = Ember['default'].K;
    this.attributeNames = [];
    this.src = null;
    this.node = null;
    this.hooksHandled = [];
  }


  (function (proto) {
    /**
     * Release the clone
     *
     * @method release
     * @chainable
     */
    proto.release = function () {
      var i,
          len,
          attrNames = this.attributeNames;
      if (this.node) {
        for (i = 0, len = attrNames.length; i < len; i++) {
          this.node.removeAttribute(attrNames[i]);
        }
        this.attributeNames = [];
        imgFactory['default'].free(this.src, this.node);
        this.node = this.src = null;
        this.handler = Ember['default'].K;
      }
      return this;
    };

    /**
     * Switch the src for this node and call the handler so that it can insert the new node into the DOM
     *
     * @method switchSrc
     * @param {string} newSrc
     * @param {HTMLImageElement} [original]
     * @param {boolean} [force=false]
     * @chainable
     */
    proto.switchSrc = function (newSrc, original) {
      var oldImg, newImg, attrNames, hasChanged;
      assert("[img-manager] Trying to switch the source of a clone holder with no node.", this.node);
      if (!newSrc) {
        newSrc = TRANSPARENT_PIXEL;
      }
      if (this.src !== newSrc) {
        oldImg = this.node;
        this.node = newImg = imgFactory['default'].forSrc(newSrc, original);
        hasChanged = false;
        attrNames = [];
        forEach(this.attributeNames, function (name) {
          var attr = oldImg.getAttributeNode(name);
          if (attr) {
            attr = oldImg.removeAttributeNode(attr);
            newImg.setAttributeNode(attr);
            attrNames.push(name);
          } else {
            hasChanged = true;
          }
        });
        if (hasChanged) {
          this.attributeNames = attrNames;
        }
        imgFactory['default'].free(this.src, oldImg);
      }
      return this;
    };

    /**
     * Use this clone with the given src, attributes and handler
     *
     * @method useWith
     * @param {string} src
     * @param {ImgCloneHolder|Object} [attributes=null]
     * @param {HTMLImageElement} [original]
     * @param {Function} [handler=Ember.K]
     * @chainable
     */
    proto.useWith = function (src, attributes, original, handler) {
      assert("[img-manager] Clone already used for src `" + this.src + "`.", !this.src);
      this.src = src || TRANSPARENT_PIXEL;
      this.node = imgFactory['default'].forSrc(this.src, original);
      this.handler = handler || Ember['default'].K;
      this._defineAttributes(attributes);
      return this;
    };

    /**
     * Call the handler only if it has not yet been triggered
     *
     * @method triggerOnce
     * @param {string} event
     * @param {string} realEvent
     */
    proto.triggerOnce = function (event, realEvent) {
      if (this.hooksHandled.indexOf(event) === -1) {
        this.hooksHandled.push(event);
        next(null, this.handler, realEvent || event, this.node);
      }
    };

    /**
     * Set one attribute of this clone
     *
     * @method setAttribute
     * @param {string} name
     * @param {*} value
     */
    proto.setAttribute = function (name, value) {
      var attrNames, index;
      attrNames = this.attributeNames;
      index = attrNames.indexOf(name);
      if (name === "src") {
        this.switchToSrc(value);
      }
      if (value == null) {
        if (index !== -1) {
          attrNames.splice(index, 1);
          this.node.removeAttribute(name);
        }
      } else {
        if (index === -1) {
          attrNames.push(name);
        }
        setAttr(this.node, name, value);
      }
    };

    /**
     * Set the attributes with given attributes array or from another clone
     *
     * @method _defineAttributes
     * @param {ImgCloneHolder|Object} cloneOrAttrs
     * @private
     */
    proto._defineAttributes = function (cloneOrAttrs) {
      if (cloneOrAttrs) {
        if (cloneOrAttrs instanceof ImgCloneHolder) {
          // move attributes from the given node to the clone
          this._importAttributes(cloneOrAttrs);
        } else {
          // set attributes
          this._setAttributes(cloneOrAttrs);
        }
      }
    };

    /**
     * Import and move attributes from the given clone
     *
     * @method _importAttributes
     * @param {ImgCloneHolder} clone
     * @private
     */
    proto._importAttributes = function (clone) {
      var node, attrNames;
      node = this.node;
      attrNames = this.attributeNames;
      forEach(clone.node.attributes, function (attr) {
        if (clone.attributeNames.indexOf(attr.localName) !== -1) {
          attr = clone.node.removeAttributeNode(attr);
          node.setAttributeNode(attr);
          attrNames.push(attr.localName);
        }
      });
      // remove the names from the index
      clone.attributeNames = filter(clone.attributeNames, function (name) {
        return attrNames.indexOf(name) !== -1;
      });
    };

    /**
     * Sets the attributes from a hash
     *
     * @method _setAttributes
     * @param {Object} attributes
     * @private
     */
    proto._setAttributes = function (attributes) {
      var name, value, node, attrNames;
      node = this.node;
      attrNames = this.attributeNames;
      for (name in attributes) {
        if (hasOwn.call(attributes, name)) {
          value = attributes[name];
          if (name !== "src" && value != null) {
            attrNames.push(name);
            setAttr(node, name, value);
          }
        }
      }
    };
  })(ImgCloneHolder.prototype);

  exports['default'] = ImgCloneHolder;

  exports.TRANSPARENT_PIXEL = TRANSPARENT_PIXEL;

});
define('dummy/utils/img-manager/img-node-factory', ['exports', 'ember', './simple-map'], function (exports, Ember, SimpleMap) {

  'use strict';

  var assert = Ember['default'].assert;


  exports['default'] = {
    /**
     * Our nodes collection
     * @property index
     * @type {SimpleMap.<{src: string, node: HTMLDivElement.<HTMLImageElement>, original: HTMLImageElement}>}
     */
    index: new SimpleMap['default'](),

    /**
     * Our container
     * @property container
     * @type {HTMLDivElement}
     */
    container: null,

    /**
     * The index for the given src
     *
     * @method indexFor
     * @param {string} src
     * @param {boolean} [createIfNotExists=false]
     * @return {{src: string, node: HTMLDivElement.<HTMLImageElement>, original: HTMLImageElement}|undefined}
     */
    indexFor: function (src, createIfNotExists) {
      var idx;
      if (!this.container) {
        if (!createIfNotExists) {
          return;
        }
        this.container = document.createElement("div");
      }
      idx = this.index.get(src);
      if (!idx) {
        if (!createIfNotExists) {
          return;
        }
        idx = Object.create(null);
        idx.src = src;
        idx.node = document.createElement("div");
        idx.original = null;
        this.index.set(src, idx);
        this.container.appendChild(idx.node);
      }
      return idx;
    },

    /**
     * Get one free node for the given src
     *
     * @method forSrc
     * @param {string} src
     * @param {HTMLImageElement} [original]
     * @return {HTMLImageElement}
     */
    forSrc: function (src, original) {
      var img, idx;
      assert("[img-manager] Can't get a clone with no `src`.", src);
      idx = this.indexFor(src, true);
      if (idx && (img = idx.node.lastChild)) {
        idx.node.removeChild(img);
        return img;
      }
      if (original) {
        img = original.cloneNode(true);
      } else {
        if (!idx.original) {
          idx.original = document.createElement("img");
          idx.original.src = src;
        }
        img = idx.original.cloneNode(true);
      }
      return img;
    },

    /**
     * Free the given img node
     *
     * @method free
     * @param {string} src
     * @param {HTMLImageElement} img
     */
    free: function (src, img) {
      assert("[img-manager] Can't free a clone with no `src`.", src);
      assert("[img-manager] Can't free a clone with undefined node for src `" + src + "`.", img);
      this.indexFor(src, true).node.appendChild(img);
    }
  };

});
define('dummy/utils/img-manager/img-rule', ['exports', 'ember'], function (exports, Ember) {

  'use strict';

  var slice = [].slice;
  var run = Ember['default'].run;
  var next = run.next;
  var debounce = run.debounce;
  var computed = Ember['default'].computed;
  var readOnly = computed.readOnly;


  function starMatcher() {
    return true;
  }
  function noneMatcher() {
    return false;
  }

  function callQueueItem(item) {
    var target = item[0],
        method = item[1],
        args = item[2];
    if (!target || !target.isDestroyed && !target.isDestroying) {
      try {
        if (typeof method === "string") {
          method = target[method];
        }
        return method.apply(target, args);
      } catch (e) {
        Ember['default'].warn("[img-manager] Error invoking load queue item: " + e);
      }
    }
  }

  function anyDefined() {
    var props = Array.prototype.slice.call(arguments);
    return computed.apply(Ember['default'], props.concat([function () {
      var val;
      for (var i = 0; i < props.length; i++) {
        val = this.get(props[i]);
        if (val != null) {
          return val;
        }
      }
    }])).readOnly();
  }

  /**
   * @module img-manager
   * @class ImgRule
   * @extends Ember.Object
   */
  exports['default'] = Ember['default'].Object.extend({
    /**
     * Our manager
     * @property manager
     * @type {ImgManagerService}
     */
    manager: null,

    /**
     * The rule's config
     * @property config
     * @type {{match: string|RegExp|Function, batchSize: number, delay: number, maxTries: number, loadingSrc: string, errorSrc: string, lazyLoad: boolean}}
     */
    config: null,

    /**
     * The number of images matching which would load at the same time
     * @property batchSize
     * @type {number}
     */
    batchSize: computed("config.batchSize", "manager.defaultBatchSize", function () {
      var batchSize = this.get("config.batchSize");
      if (batchSize === undefined) {
        batchSize = this.get("manager.defaultBatchSize");
      }
      return batchSize;
    }).readOnly(),

    /**
     * Match used to filter on `src`
     * @property match
     * @type {string|RegExp|Function}
     */
    match: readOnly("config.match"),

    /**
     * How many milliseconds to wait before loading next batch
     * @property delay
     * @type {number}
     */
    delay: anyDefined("config.delay", "manager.defaultDelay"),

    /**
     * Should we lazy load the image?
     * @property lazyLoad
     * @type {number}
     */
    lazyLoad: anyDefined("config.lazyLoad", "manager.defaultLazyLoad"),

    /**
     * The maximum number of time to try to load an image
     * @property maxTries
     * @type {number}
     */
    maxTries: anyDefined("config.maxTries", "manager.defaultMaxTries"),

    /**
     * The src to use when loading the image
     * @property loadingSrc
     * @type {string}
     */
    loadingSrc: anyDefined("config.loadingSrc", "manager.defaultLoadingSrc"),

    /**
     * The src to use when the image failed loading
     * @property errorSrc
     * @type {string}
     */
    errorSrc: anyDefined("config.errorSrc", "manager.defaultErrorSrc"),

    /**
     * How many times has it been paused
     * @property loadQueuePausedCount
     * @type {number}
     */
    loadQueuePausedCount: computed(function (key, value) {
      if (arguments.length > 1) {
        // set
        if (value === 0) {
          // time to schedule the queue processing
          next(this, "processLoadQueue");
        }
        return value;
      } else {
        // initial get
        return 0;
      }
    }),

    /**
     * Pauses the load queue processing
     *
     * @method pauseLoadQueue
     */
    pauseLoadQueue: function () {
      this.incrementProperty("loadQueuePausedCount");
    },

    /**
     * Continue the load queue processing
     *
     * @method continueLoadQueue
     */
    continueLoadQueue: function () {
      this.incrementProperty("loadQueuePausedCount", -1);
    },


    /**
     * Matcher used to find out if given src matches the rule
     * @property matcher
     * @type {Function}
     */
    matcher: computed("match", function () {
      var match = this.get("match");
      if (match === undefined || match === "*") {
        return starMatcher;
      }
      switch (typeof match) {
        case "string":
          return function (src) {
            return src.indexOf(match) !== -1;
          };
        case "function":
          return match;
        default:
          if (match instanceof RegExp) {
            return function (src) {
              return match.test(src);
            };
          } else {
            Ember['default'].warn("[img-manager] Invalid rule `match`: " + match);
            return noneMatcher;
          }
      }
    }).readOnly(),

    /**
     * Used to test if a given `src` matches our rule
     *
     * @method test
     * @param {string} src
     * @return {boolean}
     */
    test: function (src) {
      return this.get("matcher")(src);
    },

    /**
     * Schedule the given function for load
     *
     * @method scheduleForLoad
     * @param {Object} [target]
     * @param {Function|string} method
     * @param {*} [...args]
     */
    scheduleForLoad: function (target, method /*, args*/) {
      var args;
      if (arguments.length < 2) {
        method = target;
        target = null;
        args = [];
      } else {
        args = slice.call(arguments, 2);
      }
      this.get("_loadQueue").pushObject([target, method, args]);
      this.processLoadQueue();
    },

    /**
     * Process our loading queue
     *
     * @method processLoadQueue
     */
    processLoadQueue: function () {
      var opt = this.getProperties("_loadQueue", "delay", "loadQueuePausedCount");
      if (!opt._loadQueue.length || opt.loadQueuePausedCount > 0) {
        return;
      }
      this._timer = debounce(this, "_processLoadQueue", opt.delay || 1);
    },

    /**
     * Our load queue
     * @property _loadQueue
     * @type {Array.<Function>}
     * @private
     */
    _loadQueue: computed(function () {
      return [];
    }),

    /**
     * Our load queue processor
     *
     * @method _processLoadQueue
     * @private
     */
    _processLoadQueue: function () {
      var batchSize = this.get("batchSize"),
          queue = this.get("_loadQueue"),
          items;
      if (this.get("loadQueuePausedCount") === 0) {
        items = queue.splice(0, batchSize || queue.length);
        for (var i = 0; i < items.length; i++) {
          callQueueItem(items[i]);
        }
      }
      next(this, "processLoadQueue");
    }
  });

});
define('dummy/utils/img-manager/img-source', ['exports', 'ember', './dom-helpers', './img-clone-holder'], function (exports, Ember, helpers, ImgCloneHolder) {

  'use strict';

  var assert = Ember['default'].assert;
  var observer = Ember['default'].observer;
  var computed = Ember['default'].computed;
  var oneWay = computed.oneWay;
  var or = computed.or;
  var on = Ember['default'].on;
  var bind = Ember['default'].run.bind;
  var next = Ember['default'].run.next;


  var uuid = 0;
  function appendDummyQP(url) {
    if (typeof url === "string") {
      url = url.split("#");
      if (url[0].indexOf("?") === -1) {
        url[0] += "?";
      } else {
        url[0] += "&";
      }
      url[0] += "__dummy_eim__=" + ++uuid;
      url = url.join("#");
    }
    return url;
  }

  /**
   * @module img-manager
   * @class ImgSource
   * @extends Ember.Object
   * @uses Ember.Evented
   */
  exports['default'] = Ember['default'].Object.extend(Ember['default'].Evented, {
    /**
     * How many times this source has been duplicated
     * @property hits
     * @type {number}
     */
    hits: 0,

    /**
     * The src of our image
     * @property src
     * @type {string}
     */
    src: null,

    /**
     * Our manager
     * @property manager
     * @type {ImgManagerService}
     */
    manager: null,

    /**
     * Percent loaded
     * @property progress
     * @type {number}
     */
    progress: null,

    /**
     * Our matching rule
     * @property rule
     * @type {ImgRule}
     */
    rule: computed(function () {
      var opt = this.getProperties("manager", "src");
      return opt.manager.ruleForSrc(opt.src);
    }).readOnly(),

    /**
     * Are we currently loading?
     * @property isLoading
     * @type {boolean}
     */
    isLoading: true,

    /**
     * Whether the load failed or not
     * @property isError
     * @type {boolean}
     */
    isError: false,

    /**
     * Is the real load initiated?
     * @property isInitiated
     * @type {boolean}
     */
    isInitiated: false,

    /**
     * Are we ready? either loaded or error
     * @property isReady
     * @type {boolean}
     */
    isReady: or("isError", "isSuccess"),

    /**
     * Whether we are loaded successfully or not
     * @property isSuccess
     * @type {boolean}
     */
    isSuccess: computed("isLoading", "isError", function () {
      return !this.get("isLoading") && !this.get("isError");
    }),

    /**
     * Our source node
     * @property node
     * @type {HTMLImageElement}
     */
    node: computed(function () {
      return document.createElement("img");
    }).readOnly(),

    /**
     * Loads the image
     *
     * @method load
     */
    load: function () {
      var node, opt, src;
      if (!this.get("isInitiated")) {
        this.set("isInitiated", true);
        opt = this.getProperties("src", "_onLoadHandler", "_onErrorHandler", "_onProgressHandler", "maxTries");
        node = this.get("node");
        this.trigger("willLoad");
        if (opt.maxTries) {
          this.set("isLoading", true);
          this.set("progress", undefined);
          helpers['default'].attachOnce(node, "load", opt._onLoadHandler);
          helpers['default'].attachOnce(node, "error", opt._onErrorHandler);
          helpers['default'].attachOnce(node, "progress", opt._onProgressHandler);
          if (this.get("errorCount")) {
            src = appendDummyQP(opt.src);
          } else {
            src = opt.src;
          }
          this.set("modifiedSrc", src);
          node.src = src;
        } else {
          // do not even try to load the image, and directly fires the ready event
          next(this, function () {
            this.setProperties({ isError: true, isLoading: false });
            this.trigger("ready");
          });
        }
      }
    },

    /**
     * Maximum number of load tries
     * @property maxTries
     * @type {number}
     */
    maxTries: oneWay("rule.maxTries"),

    /**
     * Should we lazy load the image?
     * @property lazyLoad
     * @type {number}
     */
    lazyLoad: oneWay("rule.lazyLoad"),

    /**
     * Number of errors when trying to load the image
     * @property errorCount
     * @type {number}
     */
    errorCount: 0,

    /**
     * Our virtual src depending on our state
     * @property virtualSrc
     * @type {string}
     */
    virtualSrc: computed("isLoading", "isError", "rule.errorSrc", "rule.loadingSrc", function () {
      var opt = this.getProperties("isLoading", "isError");
      if (opt.isLoading) {
        return this.get("rule.loadingSrc");
      } else if (opt.isError) {
        return this.get("rule.errorSrc");
      } else {
        // use the node.src since we might have added some parameters for another try
        return this.get("modifiedSrc");
      }
    }).readOnly(),


    /**
     * All the existing clones for this image
     * @property cloneHolders
     * @type {Array.<ImgCloneHolder>}
     */
    cloneHolders: computed(function () {
      return [];
    }).readOnly(),

    /**
     * All the existing free clones for this image
     * @property freeCloneHolders
     * @type {Array.<ImgCloneHolder>}
     */
    freeCloneHolders: computed(function () {
      return [];
    }).readOnly(),


    /**
     * Creates a new clone with given attributes
     *
     * @method createClone
     * @param {Object} attributes
     * @param {Function} [handler]
     * @return {ImgCloneHolder}
     */
    createClone: function (attributes, handler) {
      var cloneHolder, original;
      cloneHolder = this.get("freeCloneHolders").pop();
      original = this.get("isSuccess") ? this.get("node") : null;
      if (!cloneHolder) {
        cloneHolder = new ImgCloneHolder['default']();
      }
      this.get("cloneHolders").push(cloneHolder);
      this.incrementProperty("hits");
      cloneHolder.useWith(this.get("virtualSrc"), attributes, original, handler);
      cloneHolder.triggerOnce(this.get("cloneHolderEvent"), "change");
      return cloneHolder;
    },

    /**
     * The event reference when calling triggerOnce
     * @property cloneHolderEvent
     * @type {string}
     */
    cloneHolderEvent: computed("isSuccess", "isError", function () {
      if (this.get("isSuccess")) {
        return "success";
      } else if (this.get("isError")) {
        return "error";
      }
      return "loading";
    }),


    /**
     * Release a clone
     *
     * @method releaseClone
     * @param {ImgCloneHolder} cloneHolder
     */
    releaseClone: function (cloneHolder) {
      var cloneHolders = this.get("cloneHolders"),
          index = cloneHolders.indexOf(cloneHolder);
      assert("[img-manager] Clone holder asked to be released does not belong to this source", index !== -1);
      cloneHolder.release();
      cloneHolders.splice(index, 1);
      this.get("freeCloneHolders").push(cloneHolder);
    },

    /**
     * Schedule a switch of src for all the clones when the ready event is fired
     *
     * @method switchClonesSrc
     */
    switchClonesSrc: observer("virtualSrc", function () {
      next(this, "_switchClonesSrc");
    }).on("ready"),

    /**
     * Switch the clones' src
     *
     * @method _switchClonesSrc
     * @private
     */
    _switchClonesSrc: function () {
      var opt, original, i, len, event;
      opt = this.getProperties("cloneHolders", "virtualSrc", "manager", "isSuccess", "node", "isError");
      if (opt.isSuccess) {
        original = opt.node;
      }
      event = this.get("cloneHolderEvent");
      for (i = 0, len = opt.cloneHolders.length; i < len; i++) {
        opt.cloneHolders[i].switchSrc(opt.virtualSrc, original);
        opt.cloneHolders[i].triggerOnce(event, "change");
      }
    },


    /**
     * The progress event handler
     * @property _onProgressHandler
     * @type Function
     * @private
     */
    _onProgressHandler: computed(function () {
      return bind(this, function (event) {
        if (event.lengthComputable) {
          this.set("progress", event.loaded / event.total * 100);
        }
      });
    }).readOnly(),


    /**
     * The load event handler
     * @property _onLoadHandler
     * @type Function
     * @private
     */
    _onLoadHandler: computed(function () {
      return bind(this, function (event) {
        var opt = this.getProperties("node", "_onErrorHandler", "_onProgressHandler");
        helpers['default'].detach(opt.node, "error", opt._onErrorHandler);
        helpers['default'].detach(opt.node, "progress", opt._onProgressHandler);
        this.setProperties({
          isError: false,
          isLoading: false,
          progress: 100
        });
        this.trigger("didLoad", event);
        this.trigger("ready", event);
      });
    }).readOnly(),

    /**
     * The error event handler
     * @property _onErrorHandler
     * @type Function
     * @private
     */
    _onErrorHandler: computed(function () {
      return bind(this, function (event) {
        var opt = this.getProperties("node", "_onLoadHandler", "_onProgressHandler", "maxTries", "rule");
        helpers['default'].detach(opt.node, "load", opt._onLoadHandler);
        helpers['default'].detach(opt.node, "progress", opt._onProgressHandler);
        if (this.incrementProperty("errorCount") < opt.maxTries) {
          this._continueRuleProcessingQueue();
          this.scheduleLoad(true);
        } else {
          // we're done trying, trigger the `didError` event
          this.setProperties({
            isError: true,
            isLoading: false
          });
          this.trigger("didError", event);
          this.trigger("ready", event);
        }
      });
    }).readOnly(),

    /**
     * Schedule the image load
     *
     * @method scheduleLoad
     * @param {boolean} [forceReload=false]
     * @private
     */
    scheduleLoad: function (forceReload) {
      var initiated = this.get("isInitiated");
      if (initiated && forceReload) {
        this.set("isInitiated", initiated = false);
      }
      if (!initiated) {
        this.get("rule").scheduleForLoad(this, "load");
      }
    },

    /**
     * Pauses the load processing queue
     *
     * @method _pauseRuleProcessingQueue
     * @private
     */
    _pauseRuleProcessingQueue: on("willLoad", function () {
      this.get("rule").pauseLoadQueue();
    }),

    /**
     * Continues the load processing queue
     *
     * @method _continueRuleProcessingQueue
     * @private
     */
    _continueRuleProcessingQueue: on("ready", function () {
      this.get("rule").continueLoadQueue();
    })
  });

});
define('dummy/utils/img-manager/simple-map', ['exports'], function (exports) {

  'use strict';

  function SimpleMap() {
    this.keys = [];
    this.values = [];
  }

  (function (proto) {
    proto.set = function (key, value) {
      var index = this.indexOfKey(key);
      if (index === -1) {
        this.keys.push(key);
        this.values.push(value);
      } else {
        this.values[index] = value;
      }
    };

    proto.get = function (key) {
      var index = this.indexOfKey(key);
      if (index !== -1) {
        return this.values[index];
      }
    };

    proto.unset = function (key) {
      var index = this.indexOfKey(key);
      if (index !== -1) {
        this.keys.splice(index, 1);
        return this.values.splice(index, 1)[0];
      }
    };

    proto.has = function (key) {
      return this.indexOfKey(key) !== -1;
    };

    proto.indexOfKey = function (key) {
      return this.keys.indexOf(key);
    };

    proto.indexOfValue = function (value) {
      return this.values.indexOf(value);
    };

    proto.size = function () {
      return this.keys.length;
    };
  })(SimpleMap.prototype);

  exports['default'] = SimpleMap;

});
/* jshint ignore:start */

define('dummy/config/environment', ['ember'], function(Ember) {
  var prefix = 'dummy';
/* jshint ignore:start */

try {
  var metaName = prefix + '/config/environment';
  var rawConfig = Ember['default'].$('meta[name="' + metaName + '"]').attr('content');
  var config = JSON.parse(unescape(rawConfig));

  return { 'default': config };
}
catch(err) {
  throw new Error('Could not read config from meta tag with name "' + metaName + '".');
}

/* jshint ignore:end */

});

if (runningTests) {
  require("dummy/tests/test-helper");
} else {
  require("dummy/app")["default"].create({});
}

/* jshint ignore:end */
//# sourceMappingURL=dummy.map